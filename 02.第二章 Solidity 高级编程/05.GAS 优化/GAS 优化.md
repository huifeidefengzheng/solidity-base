# GAS 优化

Gas 优化是开发以太坊智能合约一项非常有挑战性的任务。以太坊上的计算资源是有限的，每个区块可用的 Gas 是有个上限的，本书编写时，单个区块区块限制约为 1250 万。进入 2020 年后，随着链上去中心化金融应用的兴起，以太坊的利用率逐渐增长，由于矿工是 gas 价格竞价排名的方式打包区块，当以太坊的利用率非常高时，只有高 Gas 价格的交易才能得到打包的机会，从而按导致交易手续费一直居高不下。在这样的背景下，优化合约交易的 gas 耗用量就显得更加重要。

### 2.5.1 变量打包

合约内总是用连续 32 字节（256 位）的插槽来储存状态变量。当操作者在一个插槽中放置多个变量，它被称为变量打包。

**存储操作码指令(SSTORE)消耗的 Gas 成本非常高，首次写时，每个 32 个字节的成本是为 20,000 Gas，而后续每次修改则为 5,000 Gas，变量打包可以减少 SSTORE 指令的使用。**

变量打包就像俄罗斯方块游戏。如果打包的变量超过当前槽的 32 字节限制，它将被存储在一个新的插槽中。操作者必须找出哪些变量最适合放在一起，以最小化浪费的空间。因为使用每个插槽都需要消耗 Gas，变量打包通过减少合约要求插槽数量，帮助优化 Gas 的使用，下面代码是一个例子：

uint128 a;

uint256 b;

uint128 c;

这些变量无法打包。如果 b 和 a 打包在一起，那么就会超过 32 字节的限制，所以会被放在新的一个储存插槽中。同样 c 和 b 打包也如此。

而使用下面的顺序定义变量，就更好：

uint128 a;

uint128 c;

uint256 b;

因为 c 和 a 打包之后不会超过 32 字节，他们可以被存放在一个插槽中。

在选择数据类型时，留心变量打包，如果刚好可以与其他变量打包放入一个储存插槽中，那么使用一个小数据类型是不错的。

但是当变量无法和合并打包时，应该尽量使用 256 位的变量，例如 uint256 和 bytes32！，因为以太坊虚拟机(EVM)的运行时，总是一次处理 32 个字节，如果只存储一个 uint8，EVM 其实会用零填充所有缺少的数字，这会耗费 gas。同时，EVM 执行计算也执行类型转化，转化为 uint256，因此使用 256 位的变量会更有效率。

### 2.5.2 选择适合的数据类型

1. **使用常量或不可变量**

如果一个数据不会在合约运行中，其值一直是固定的，这应该使用常量（constant）或不可变量（immutable）。因为他们是将数据包含在智能合约字节码中，这样用于加载和存储数据的 gas 消耗将大大减少。

```solidity
contract C { 
uint constant X = 32**22 + 8; // 定义常量 
string constant TEXT = "abc"; 
uint immutable decimals; // 定义不可变量 
constructor(uint _d) { decimals = _d; 
} 
}
```

常量与不可变量的区别是，常量在编译期确定值，不可变量在部署时确定值。

2. **固定长度比变长更好**

如果能确定一个数组有多少元素，应该优先采用固定大小的方式，例如，下面是一个按月存储的数据，可以使用 12 个元素的数组；

uint256[12] monthlys;

这同样也适用于字符型，一个 string 或者 bytes 变量是变长的。如果一个字符串很短，则应该使用固定长度的 bytes1~bytes32 类型。

3. **映射和数组**

大多数的情况下，使用映射的 gas 消耗会优于数组，映射存储、读取、删除的 gas 消耗都是固定的，而数组的 gas 消耗会随数组长度增长而线性增长。

不过，当数组元素类型是较小的数据类型，数组是一个不错的选择。数组元素会像其他存储变量被打包，这样可节省存储空间可能以弥补昂贵数组操作。

如果必须要设计一个动态数组，也需要尽量让数组保持末尾递增，避免数组的移位。

### 2.5.3 内存和存储

在内存中操作数据，比存储中操作状态变量数据便宜得多。减少存储操作的一种常见方法是在分配给存储变量之前，使用内存变量其进行操作。

例如下面的 solidity 代码中，num 变量是一个存储型状态变量，那么在每次循环中都操作 num 很浪费 gas ：

```solidity
uint num = 0; 
 function expensiveLoop(uint x) public { 
 for(uint i = 0; i < x; i++) { 
 num += 1; 
 } 
 }
```

可以创建一个临时变量，来代替上述全局变量参与循环，然后在循环结束后重新将临时变量的值赋给全局状态变量：

```solidity
uint num = 0; 
function lessExpensiveLoop(uint x) public { 
uint temp = num; 
for(uint i = 0; i < x; i++) { 
temp += 1; 
} 
num = temp; 
}
```

### 2.5.4 减少存储

1. **清理存储**

根据 EVM 的规则，在删除状态变量时，EVM 会返还一部分 gas，返还的 gas 可以用来抵消交易的消耗的 gas。尤其在清理大数据变量时，返还的 gas 将相当可观，最高可达交易消耗 Gas 的一半。

```solidity
contract DelC { 
uint [] bigArr; 
function doSome() public { // do some 
delete bigArr; 
} 
}
```

同样的道理，当有一个合约不再需要使用，可以把合约销毁返还 gas。

2. 使用事件储存数据 那些不需要在链上被访问的数据可以存放在事件中来达到节省 Gas 的目的。触发事件的 LOG 指令基础费用是 375gas，远小于 SSTORE 指令。 例如要记录文档的注册记录，很多时候不加思索，会这样写： contract Registry { mapping (uint256 => address) public documents; function register(uint256 hash) public { documents[hash] = msg.sender; } } 其实下面更高效： contract DocumentRegistry { event Registered(uint256 hash, address sender); function register(uint256 hash) public { emit Registered(hash, msg.sender); } } 在这个合约没有任何变量存储，但是实现了同样的功能，事件记录同样会在区块链上永久保存，在需要查询数据时，可以通过订阅事件把数据缓存到数据库来查询记录。

### 2.5.5 其他建议

1. **初始化**

在 Solidity 中，每个变量的赋值都要消耗 Gas。在初始化变量时，避免使用默认值初始化，例如 uint256 value; 比 uint256 value = 0; 更便宜。

2. **Require 字符串**

如果操作者在 require 中增加语句，可以通过限制字符串长度为 32 字节来降低 Gas 消耗。

3. **精确的声明函数可见性**

在 Solidity 合约开发中，显式声明函数的可见性不仅可以提高智能合约的安全性，同时也有利于优化合约执行的 gas 成本。例如，仅会通过外部执行的函数应该显式地标记函数为外部函数（External）而不是笼统的使用公共函数（public）。

4. **链下计算**

例如在排序列表中，向列表中添加元素后，依旧要确保其仍是排序的，经验不足的实现需要在整个集合中进行迭代，以找到合适的位置进行插入，一种更有效的方法是在链下计算合适的位置，仅在链上进行相应的验证(例如：添加的值时候位于其相邻元素之间)，这可以防止成本随数据结构的总大小线性增长。

5. **警惕循环**

当合约中存在依赖时间、依赖数据大小（如数组长度）的循环时，很多能导致潜在的漏洞。随数据量的增多（或时间的增长），gas 的消耗就可能对应的线性增长，很可能突破区块限制导致无法打包。

首先要尽可能避免使用这种循环，将依靠循环的线性增长的计算量尽可能转化为固定的计算量大小（或常量）。如果没法做到转换，那就要考虑限制循环的次数，即限制总数据的大小，把一个大数据分拆为多个分段的小数据。(即想办法限制单次的计算量大小)，比如依靠时间长度计算收益的质押合约，可以采用设置质押有效期，比如设置质押有效期最长为一年，一年到期之后，用户需提取再质押。
